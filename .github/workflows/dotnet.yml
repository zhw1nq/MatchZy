name: .NET Auto Build & Release

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

env:
  PROJECT_PATH: "MatchZy.csproj"
  PROJECT_NAME: "MatchZy"
  OUTPUT_PATH: "./MatchZy"
  BASE_VERSION: "3.0.0"

permissions:
  contents: write
  pull-requests: write
  packages: write

jobs:
  calculate-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      should-release: ${{ steps.version.outputs.should-release }}
      is-prerelease: ${{ steps.version.outputs.is-prerelease }}
    steps:
    - name: Checkout
      uses: actions/checkout@v5
      with:
        fetch-depth: 0

    - name: Calculate Version
      id: version
      run: |
        BASE_VERSION="${{ env.BASE_VERSION }}"
        CURRENT_VERSION=""
        SHOULD_RELEASE="false"
        IS_PRERELEASE="false"
        
        # L·∫•y version t·ª´ latest tag (n·∫øu c√≥)
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        if [ ! -z "$LATEST_TAG" ]; then
          # Remove 'v' prefix n·∫øu c√≥
          CURRENT_VERSION=$(echo $LATEST_TAG | sed 's/^v//')
        else
          CURRENT_VERSION="$BASE_VERSION"
        fi
        
        echo "Current version: $CURRENT_VERSION"
        
        # Parse version numbers
        IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
        
        # N·∫øu l√† PR, t·∫°o prerelease version
        if [ "${{ github.event_name }}" == "pull_request" ]; then
          NEW_VERSION="$CURRENT_VERSION-pr${{ github.event.number }}.$(git rev-parse --short HEAD)"
          SHOULD_RELEASE="true"
          IS_PRERELEASE="true"
        elif [ "${{ github.event_name }}" == "push" ]; then
          # Ki·ªÉm tra commit messages t·ª´ l·∫ßn release cu·ªëi
          if [ ! -z "$LATEST_TAG" ]; then
            COMMITS=$(git log ${LATEST_TAG}..HEAD --pretty=format:"%s" --no-merges)
          else
            # L·∫•y commits t·ª´ 24h tr∆∞·ªõc (cho l·∫ßn ƒë·∫ßu)
            COMMITS=$(git log --since="24 hours ago" --pretty=format:"%s" --no-merges)
          fi
          
          echo "Analyzing commits:"
          echo "$COMMITS"
          
          # Determine version bump type
          if echo "$COMMITS" | grep -qiE "^(feat|feature)(\(.+\))?!:|^.+!:|BREAKING CHANGE|breaking change"; then
            # Major version bump
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            SHOULD_RELEASE="true"
          elif echo "$COMMITS" | grep -qiE "^(feat|feature)(\(.+\))?:|^(add|new)"; then
            # Minor version bump
            MINOR=$((MINOR + 1))
            PATCH=0
            SHOULD_RELEASE="true"
          elif echo "$COMMITS" | grep -qiE "^(fix|bugfix)(\(.+\))?:|^(patch|update|hotfix)"; then
            # Patch version bump
            PATCH=$((PATCH + 1))
            SHOULD_RELEASE="true"
          elif [ ! -z "$COMMITS" ]; then
            # Auto patch bump cho b·∫•t k·ª≥ commit n√†o kh√°c
            PATCH=$((PATCH + 1))
            SHOULD_RELEASE="true"
          fi
          
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
        else
          NEW_VERSION="$CURRENT_VERSION"
        fi
        
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "should-release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
        echo "is-prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
        
        echo "New version: $NEW_VERSION"
        echo "Should release: $SHOULD_RELEASE"
        echo "Is prerelease: $IS_PRERELEASE"

  update-source-version:
    runs-on: ubuntu-latest
    needs: calculate-version
    if: needs.calculate-version.outputs.should-release == 'true' && github.event_name == 'push'
    steps:
    - name: Checkout
      uses: actions/checkout@v5
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Update ModuleVersion in source code
      run: |
        NEW_VERSION="${{ needs.calculate-version.outputs.version }}"
        
        echo "Updating ModuleVersion to $NEW_VERSION"
        
        # T√¨m v√† c·∫≠p nh·∫≠t ModuleVersion trong c√°c file C#
        find . -name "*.cs" -type f -exec grep -l "ModuleVersion.*=>" {} \; | while read file; do
          echo "Updating $file"
          # Backup file
          cp "$file" "$file.bak"
          
          # Update version - flexible pattern matching
          sed -i.tmp "s/ModuleVersion.*=>.*\"[0-9]*\.[0-9]*\.[0-9]*\"/ModuleVersion => \"$NEW_VERSION\"/g" "$file"
          
          # N·∫øu kh√¥ng t√¨m th·∫•y pattern tr√™n, th·ª≠ pattern kh√°c
          if ! grep -q "ModuleVersion.*=>.*\"$NEW_VERSION\"" "$file"; then
            sed -i.tmp "s/public.*override.*string.*ModuleVersion.*{.*get.*}.*\"[0-9]*\.[0-9]*\.[0-9]*\"/public override string ModuleVersion { get; } = \"$NEW_VERSION\"/g" "$file"
          fi
          
          rm -f "$file.tmp" "$file.bak"
          
          if grep -q "ModuleVersion.*$NEW_VERSION" "$file"; then
            echo "‚úÖ Successfully updated $file"
          else
            echo "‚ö†Ô∏è  Could not update $file - please check the format"
          fi
        done

    - name: Commit version update
      run: |
        NEW_VERSION="${{ needs.calculate-version.outputs.version }}"
        
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        if git diff --quiet; then
          echo "No changes to commit"
          exit 0
        fi
        
        git add -A
        git commit -m "chore: bump version to $NEW_VERSION [skip ci]"
        git push

  build:
    runs-on: ubuntu-latest
    needs: [calculate-version, update-source-version]
    if: always() && needs.calculate-version.outputs.should-release == 'true'
    steps:
    - name: Checkout
      uses: actions/checkout@v5

    # Pull latest changes n·∫øu c√≥ version update
    - name: Pull latest changes
      if: github.event_name == 'push'
      run: git pull origin main || true

    - name: Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: 8.0.x

    - name: Restore
      run: dotnet restore

    - name: Build
      run: |
        VERSION="${{ needs.calculate-version.outputs.version }}"
        echo "Building version: $VERSION"
        
        # Create output directory if it doesn't exist
        mkdir -p ${{ env.OUTPUT_PATH }}
        
        # Build the project
        dotnet build ${{ env.PROJECT_PATH }} -c Release -o ${{ env.OUTPUT_PATH }} -p:Version=$VERSION
        
        # Verify build output
        echo "Build output contents:"
        ls -la ${{ env.OUTPUT_PATH }}

    - name: Test (if test project exists)
      run: |
        if find . -name "*.Tests.csproj" -o -name "*Test*.csproj" | grep -q .; then
          echo "Running tests..."
          dotnet test --no-build --verbosity normal --configuration Release
        else
          echo "No test projects found, skipping tests"
        fi

    - name: Create installation instructions
      run: |
        VERSION="${{ needs.calculate-version.outputs.version }}"
        
        # Ensure output directory exists
        mkdir -p ${{ env.OUTPUT_PATH }}
        
        cat > ${{ env.OUTPUT_PATH }}/INSTALL.md << EOF
        # MatchZy v$VERSION - Installation Instructions
        
        ## Installation
        1. Extract the zip file
        2. Place the MatchZy folder in: \`game/csgo/addons/counterstrikesharp/plugins/\`
        3. Restart your Counter-Strike server
        
        ## Version Info
        - Version: $VERSION
        - Build Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
        - Commit: $(git rev-parse --short HEAD)
        
        ## Support
        - GitHub: ${{ github.server_url }}/${{ github.repository }}
        - Issues: ${{ github.server_url }}/${{ github.repository }}/issues
        EOF
        
        echo "Installation instructions created successfully"
        echo "Directory contents:"
        ls -la ${{ env.OUTPUT_PATH }}

    - name: Zip Release
      uses: thedoctor0/zip-release@0.7.6
      with:
        type: "zip"
        filename: "${{ env.PROJECT_NAME }}-${{ needs.calculate-version.outputs.version }}.zip"
        path: ${{ env.OUTPUT_PATH }}

    - name: Upload Build Artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.PROJECT_NAME }}-${{ needs.calculate-version.outputs.version }}
        path: ${{ env.PROJECT_NAME }}-${{ needs.calculate-version.outputs.version }}.zip

  release:
    runs-on: ubuntu-latest
    needs: [calculate-version, build]
    if: needs.calculate-version.outputs.should-release == 'true'
    steps:
    - name: Checkout
      uses: actions/checkout@v5
      with:
        fetch-depth: 0

    - name: Download Build Artifact
      uses: actions/download-artifact@v5
      with:
        name: ${{ env.PROJECT_NAME }}-${{ needs.calculate-version.outputs.version }}

    - name: Generate Changelog
      id: changelog
      run: |
        VERSION="${{ needs.calculate-version.outputs.version }}"
        LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        
        echo "## üöÄ MatchZy v$VERSION" > changelog.md
        echo "" >> changelog.md
        
        # Installation instructions
        echo "### üì• Installation" >> changelog.md
        echo "Place the MatchZy folder in \`game/csgo/addons/counterstrikesharp/plugins/\`" >> changelog.md
        echo "" >> changelog.md
        
        # Changes section
        echo "### üîÑ Changes" >> changelog.md
        if [ ! -z "$LATEST_TAG" ]; then
          git log ${LATEST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges >> changelog.md
        else
          git log --pretty=format:"- %s (%h)" --no-merges --max-count=10 >> changelog.md
        fi
        echo "" >> changelog.md
        
        # Build info
        echo "### ‚ÑπÔ∏è Build Information" >> changelog.md
        echo "- Build Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> changelog.md
        echo "- Commit: $(git rev-parse HEAD)" >> changelog.md
        echo "- .NET Version: 8.0" >> changelog.md
        echo "" >> changelog.md
        
        if [ ! -z "$LATEST_TAG" ]; then
          echo "**Full Changelog**: [$LATEST_TAG...v$VERSION](${{ github.server_url }}/${{ github.repository }}/compare/${LATEST_TAG}...v$VERSION)" >> changelog.md
        fi
        
        # Set multiline output
        {
          echo 'CHANGELOG<<EOF'
          cat changelog.md
          echo EOF
        } >> $GITHUB_OUTPUT

    - name: Create GitHub Release
      uses: ncipollo/release-action@v1.20.0
      with:
        artifacts: ${{ env.PROJECT_NAME }}-${{ needs.calculate-version.outputs.version }}.zip
        name: "MatchZy v${{ needs.calculate-version.outputs.version }}"
        tag: "v${{ needs.calculate-version.outputs.version }}"
        body: ${{ steps.changelog.outputs.CHANGELOG }}
        prerelease: ${{ needs.calculate-version.outputs.is-prerelease }}
        makeLatest: ${{ github.event_name == 'push' && needs.calculate-version.outputs.is-prerelease == 'false' }}

  dependabot-auto-merge:
    runs-on: ubuntu-latest
    if: github.actor == 'dependabot[bot]' && github.event_name == 'pull_request'
    steps:
    - name: Dependabot metadata
      id: metadata
      uses: dependabot/fetch-metadata@v2
      with:
        github-token: "${{ secrets.GITHUB_TOKEN }}"

    - name: Auto-approve Dependabot PRs
      if: steps.metadata.outputs.update-type == 'version-update:semver-patch' || steps.metadata.outputs.update-type == 'version-update:semver-minor'
      run: |
        gh pr review --approve "$PR_URL"
      env:
        PR_URL: ${{github.event.pull_request.html_url}}
        GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}

    - name: Enable auto-merge for Dependabot PRs
      if: steps.metadata.outputs.update-type == 'version-update:semver-patch' || steps.metadata.outputs.update-type == 'version-update:semver-minor'
      run: |
        gh pr merge --auto --squash "$PR_URL"
      env:
        PR_URL: ${{github.event.pull_request.html_url}}
        GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}